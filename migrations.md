# Миграции

Из этой статьи вы узнаете:
- что такое миграции
- как с их помощью управлять структурой базы данных вашего приложения
- как создавать и использовать миграции в rails-приложении
- пару "лучших практик" по работе с миграциями

## База данных и её структура

При создании практически любого современного приложения нам понадобится база данных. Так или иначе, нам нужно будет хранить, записывать, обрабатывать данные. Например, заказы пользователей, информацию о поездках, тексты уроков, что угодно.

Чтобы работать с данными, нужна определённая структура, которую и предоставляет база данных. Но мы не можем задать эту структуру раз и навсегда. Наше приложение со временем будет развиваться, нужно будет не только добавлять, обновлять и удалять записи, но и менять структуру базы. Например, создавать новые таблицы или удалять ненужные, добавлять поля или менять их типы, создавать индексы и т.д.

На первый взгляд кажется, что достаточно просто выполнить соответствующие SQL-запросы — `ALTER TABLE`, `CREATE TABLE` и так далее. Однако при таком подходе быстро возникнут проблемы: например, сложно будет отслеживать историю изменений и синхронизировать структуру базы между несколькими окружениями.

[TODO: тут хочу пояснить продакшен, стейдж, разраб]

Чтобы подобных проблем не возникало, используется механизм миграций.

### Миграции

**Миграции** - это способ управления изменениями структуры базы данных вашего приложения. Также миграциями называют сами файлы с описаниями изменений, которые вы хотите сделать. В том или ином виде механизм миграций есть не только в ruby on rails. Он реализован и в других фреймворках: например, Django, Symphony. Возможно, вы уже с ним знакомы.

Иногда миграции пишут в sql-файлах:

```sql
CREATE TABLE users (
  id INTEGER PRIMARY KEY ,
  first_name VARCHAR(100),
  email VARCHAR(100)
);
```

или:

```sql
ALTER TABLE users
ADD birthday date; 
```

В ruby on rails миграции реализованы с помощью ActiveRecord, и мы пишем их прямо на Ruby с помощью DSL. Domain Specific Language (Предметно-ориентированный язык) — язык, специализированный под конкретную область применения.

Чтобы создать файл миграции, воспользуйтесь командой `rails generate` и передайте ей название миграции, которое отражает суть изменений:

```bash
# создадим миграцию для создания таблицы с данными пользователей
bin/rails generate migration CreateUsers
```

Rails автоматически добавит метку времени к названию миграции. Название файла будет в формате `20252205100843_create_users.rb`. Метки времени определяют, в каком порядке будут выполнены миграции. Rails хранит информацию о миграциях в таблице `schema_migrations`. Это важно учитывать, если вы по какой-то причине редактируете название файла или копируете его из другого приложения.   

[TODO: тут может убрать про редактирование или написать "если что, так не делайте"]

[Больше о версионировании миграций в гайдах](https://guides.rubyonrails.org/active_record_migrations.html#rails-migration-version-control)

Директория `db/migrate` будет выглядеть примерно так:  

![список файлов миграций](./images/image.png)

Если передать команде `rails generate migration` поля и их типы в качестве аргументов, они появятся в файле миграции.

```bash
# в этой миграции добавим поле birthday типа date к таблице users
$ bin/rails generate migration AddBirthdayToUsers birthday:date
```

```ruby
class AddBirthdayToUsers < ActiveRecord::Migration[8.0]
  def change
    add_column :users, :birthday, :date
  end
end
```

Передавать поля не обязательно, также вы сможете отредактировать файл после создания.  

Посмотрим ещё пару примеров миграций:

```ruby
# эта миграция создаст таблицу products
# db/migrate/20240502100843_create_products.rb
class CreateProducts < ActiveRecord::Migration[8.0]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description
      t.timestamps
    end
  end
end
```
или  

```ruby
# эта миграция добавит поле к таблице products и индекс на это поле

class AddPartNumberToProducts < ActiveRecord::Migration[8.0]
  def change
    add_column :products, :part_number, :string
    add_index :products, :part_number
  end
end
```

`timestamps` добавит 2 колонки: `created_at` и `updated_at`. Это специальные колонки, в которых будут храниться время и дата создания и обновления записи. Записывать в них данные в коде приложения не нужно, Active Record будет делать это автоматически.

`ActiveRecord::Migration[8.0]` - в квадратных скобках указана версия фреймворка,  с помощью которой была создана миграция. Бгагодаря такому версионированию, после апгрейда Rails старые миграции продолжат работать, даже если были изменения в механизме миграций

[Подробнее о реализации версионирования в коде rails](https://github.com/rails/rails/blob/65014e2379546e25407e87e5b3a056e0460361c7/activerecord/lib/active_record/migration/compatibility.rb#L16-L31)

### Применяем изменения

Чтобы применить изменения, выполните команду:

```bash
bin/rails db:migrate
```

Также эту команду нужно выполнить, если мы подтянули из репозитория изменения других разработчиков с новыми миграциями. Если забыли, то при запуске приложения или тестов rails нам об этом подскажет. 

Также миграции важно "прогнать" при деплое приложения на тестовый или продакшен-сервер.

### Откат миграций


Если хотите изменить миграцию, нельзя просто её отредактировать. Сначала придётся откатить сделанные изменения, а потом ещё раз выполнить `db:migrate`. Откатить можно командой `db:rollback`.

Обычно мы не редактируем миграции, потому что в таком случае придётся следить за их "откатом" в разных окружениях и в копиях баз данных других разработчиков. Откатить миграцию удобно, если вы только что её создали, поняли, что ошиблись и уже хотите её поменять. Тогда команда `db:rollback` будет полезна.

В других случаях лучше создать новую миграцию, противоположную той, которую хотите отменить.

### DSL и SQL в миграциях

ActiveRecord предоставляет [хелперы](https://guides.rubyonrails.org/active_record_migrations.html#updating-migrations) для изменений структуры базы данных.  Вы уже видели примеры: `create_table` , `alter_table`, `add_column` .

Если функциональности хелперов не хватает, напишите SQL и выполнить его командой `execute`. Если используете SQL, явно пропишите логику отката в методе `down`, чтобы миграция была обратимой. 

```ruby
class CreateCarUsers2 < ActiveRecord::Migration[8.0]
  def up
    execute "CREATE TABLE cars_users2 AS SELECT DISTINCT * FROM cars_users;"
  end

  def down
    execute "DROP TABLE cars_users2;"
  end
end
```

### Изменение данных, а не структуры

Иногда нужно поменять не только структуру базы, но и сами данные. Например, заполнить поле данными по умолчанию.

```ruby
# так не делайте!

class UpdateProductsPrice < ActiveRecord::Migration[8.0]
  def change
    Product.where(price: nil).update_all("price = 0")
  end
end
```

Лучше сделать это в дата-миграциях, такие миграции позволят нам логически отделить изменения структуры от изменения данных в приложении.
Для миграций данных существуют специальные гемы: [maintenance_tasks](https://github.com/Shopify/maintenance_tasks), [data-migrate](https://github.com/ilyakatz/data-migrate)

Также не стоит использовать в миграциях  модели и другой код приложения -- со временем код изменится, модели и методы будут изменены или удалены, тогда миграции перестанут работать.

### Вывод

Миграции помогают нам:
- вносить изменения в структуру базы данных нашего приложения
- синхронизировать эти изменения между машинами разработчиков, тестовыми и production-серверами
- отслеживать изменения структуры базы данных с развитием нашего приложения
